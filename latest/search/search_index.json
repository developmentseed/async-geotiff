{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"async-geotiff","text":"<p>Async GeoTIFF and Cloud-Optimized GeoTIFF (COG) reader for Python, wrapping <code>async-tiff</code>.</p>"},{"location":"#project-goals","title":"Project Goals:","text":"<ul> <li>Support only for GeoTIFF and Cloud-Optimized GeoTIFF (COG) formats</li> <li>Support for reading only, no writing support</li> <li>Full type hinting.</li> <li>API similar to rasterio where possible.<ul> <li>We won't support the full rasterio API, but we'll try to when it's possible to implement rasterio APIs with straightforward maintenance requirements.</li> <li>For methods where we do intentionally try to match with rasterio, the tests should match against rasterio.</li> </ul> </li> <li>Initially, we'll try to support a core set of GeoTIFF formats. Obscure GeoTIFF files may not be supported.</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>aiocogeo: geospatial-jeff/aiocogeo</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2026-mm-dd","title":"0.1.0 - 2026-MM-DD","text":"<ul> <li>Initial release of async-geotiff.</li> </ul>"},{"location":"api/array/","title":"async_geotiff.Array","text":""},{"location":"api/array/#async_geotiff.Array","title":"async_geotiff.Array  <code>dataclass</code>","text":"<p>               Bases: <code>TransformMixin</code></p> <p>An array representation of data from a GeoTIFF.</p>"},{"location":"api/array/#async_geotiff.Array.count","title":"count  <code>instance-attribute</code>","text":"<pre><code>count: int\n</code></pre> <p>The number of bands in the array.</p>"},{"location":"api/array/#async_geotiff.Array.crs","title":"crs  <code>instance-attribute</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The coordinate reference system of the array.</p>"},{"location":"api/array/#async_geotiff.Array.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: NDArray\n</code></pre> <p>The array data with shape (bands, height, width).</p>"},{"location":"api/array/#async_geotiff.Array.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height: int\n</code></pre> <p>The height of the array in pixels.</p>"},{"location":"api/array/#async_geotiff.Array.mask","title":"mask  <code>instance-attribute</code>","text":"<pre><code>mask: NDArray[bool_] | None\n</code></pre> <p>The mask array with shape (height, width), if any.</p> <p>Values of True indicate valid data; False indicates no data.</p>"},{"location":"api/array/#async_geotiff.Array.transform","title":"transform  <code>instance-attribute</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>The affine transform mapping pixel coordinates to geographic coordinates.</p>"},{"location":"api/array/#async_geotiff.Array.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width: int\n</code></pre> <p>The width of the array in pixels.</p>"},{"location":"api/array/#async_geotiff.Array.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/array/#async_geotiff.Array.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/geotiff/","title":"async_geotiff.GeoTIFF","text":""},{"location":"api/geotiff/#async_geotiff.GeoTIFF","title":"async_geotiff.GeoTIFF  <code>dataclass</code>","text":"<p>               Bases: <code>FetchTileMixin</code>, <code>TransformMixin</code></p> <p>A class representing a GeoTIFF image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.block_shapes","title":"block_shapes  <code>property</code>","text":"<pre><code>block_shapes: list[tuple[int, int]]\n</code></pre> <p>An ordered list of block shapes for each bands.</p> <p>Shapes are tuples and have the same ordering as the dataset's shape:</p> <ul> <li>(count of image rows, count of image columns).</li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.bounds","title":"bounds  <code>cached</code> <code>property</code>","text":"<pre><code>bounds: tuple[float, float, float, float]\n</code></pre> <p>Return the bounds of the dataset in the units of its CRS.</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float, float]</code>           \u2013            <p>(lower left x, lower left y, upper right x, upper right y)</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.colorinterp","title":"colorinterp  <code>property</code>","text":"<pre><code>colorinterp: list[str]\n</code></pre> <p>The color interpretation of each band in index order.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.compression","title":"compression  <code>property</code>","text":"<pre><code>compression: Compression\n</code></pre> <p>The compression algorithm used for the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>The number of raster bands in the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The dataset's coordinate reference system.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.dtypes","title":"dtypes  <code>property</code>","text":"<pre><code>dtypes: list[str]\n</code></pre> <p>The data types of each band in index order.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>The height (number of rows) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.interleaving","title":"interleaving  <code>property</code>","text":"<pre><code>interleaving: Interleaving\n</code></pre> <p>The interleaving scheme of the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.is_tiled","title":"is_tiled  <code>property</code>","text":"<pre><code>is_tiled: bool\n</code></pre> <p>Check if the dataset is tiled.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.nodata","title":"nodata  <code>property</code>","text":"<pre><code>nodata: float | None\n</code></pre> <p>The dataset's single nodata value.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.overviews","title":"overviews  <code>property</code>","text":"<pre><code>overviews: list[Overview]\n</code></pre> <p>A list of overview levels for the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.photometric","title":"photometric  <code>property</code>","text":"<pre><code>photometric: PhotometricInterpretation | None\n</code></pre> <p>The photometric interpretation of the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.res","title":"res  <code>property</code>","text":"<pre><code>res: tuple[float, float]\n</code></pre> <p>Return the (width, height) of pixels in the units of its CRS.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int]\n</code></pre> <p>Get the shape (height, width) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int\n</code></pre> <p>The height in pixels per tile of the image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int\n</code></pre> <p>The width in pixels per tile of the image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>Return the dataset's georeferencing transformation matrix.</p> <p>This transform maps pixel row/column coordinates to coordinates in the dataset's CRS.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>The width (number of columns) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.__init__","title":"__init__","text":"<pre><code>__init__(tiff: TIFF) -&gt; None\n</code></pre> <p>Create a GeoTIFF from an existing TIFF instance.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.block_size","title":"block_size","text":"<pre><code>block_size(bidx: int, i: int, j: int) -&gt; int\n</code></pre> <p>Return the size in bytes of a particular block.</p> <p>Parameters:</p> <ul> <li> <code>bidx</code>               (<code>int</code>)           \u2013            <p>Band index, starting with 1.</p> </li> <li> <code>i</code>               (<code>int</code>)           \u2013            <p>Row index of the block, starting with 0.</p> </li> <li> <code>j</code>               (<code>int</code>)           \u2013            <p>Column index of the block, starting with 0.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.colormap","title":"colormap","text":"<pre><code>colormap(bidx: int) -&gt; dict[int, tuple[int, int, int]]\n</code></pre> <p>Return a dict containing the colormap for a band.</p> <p>Parameters:</p> <ul> <li> <code>bidx</code>               (<code>int</code>)           \u2013            <p>The 1-based index of the band whose colormap will be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[int, tuple[int, int, int]]</code>           \u2013            <p>Mapping of color index value (starting at 0) to RGBA color as a</p> </li> <li> <code>dict[int, tuple[int, int, int]]</code>           \u2013            <p>4-element tuple.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no colormap is found for the specified band (NULL color table).</p> </li> <li> <code>IndexError</code>             \u2013            <p>If no band exists for the provided index.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(xs: list[int], ys: list[int]) -&gt; list[Array]\n</code></pre> <p>Fetch multiple tiles from this overview.</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>list[int]</code>)           \u2013            <p>The x coordinates of the tiles.</p> </li> <li> <code>ys</code>               (<code>list[int]</code>)           \u2013            <p>The y coordinates of the tiles.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.indexes","title":"indexes","text":"<pre><code>indexes() -&gt; list[int]\n</code></pre> <p>Return the 1-based indexes of each band in the dataset.</p> <p>For a 3-band dataset, this property will be [1, 2, 3].</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.open","title":"open  <code>async</code> <code>classmethod</code>","text":"<pre><code>open(\n    path: str,\n    *,\n    store: ObjectStore | ObspecInput,\n    prefetch: int = 32768,\n    multiplier: float = 2.0\n) -&gt; Self\n</code></pre> <p>Open a new GeoTIFF.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to read from.</p> </li> <li> <code>store</code>               (<code>ObjectStore | ObspecInput</code>)           \u2013            <p>The backend to use for data fetching.</p> </li> <li> <code>prefetch</code>               (<code>int</code>, default:                   <code>32768</code> )           \u2013            <p>The number of initial bytes to read up front.</p> </li> <li> <code>multiplier</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The multiplier to use for readahead size growth. Must be greater than 1.0. For example, for a value of <code>2.0</code>, the first metadata read will be of size <code>prefetch</code>, and then the next read will be of size <code>prefetch * 2</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A TIFF instance.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/overview/","title":"async_geotiff.Overview","text":""},{"location":"api/overview/#async_geotiff.Overview","title":"async_geotiff.Overview  <code>dataclass</code>","text":"<p>               Bases: <code>FetchTileMixin</code>, <code>TransformMixin</code></p> <p>An overview level of a Cloud-Optimized GeoTIFF image.</p>"},{"location":"api/overview/#async_geotiff.Overview.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The coordinate reference system of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>The height of the overview in pixels.</p>"},{"location":"api/overview/#async_geotiff.Overview.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int\n</code></pre> <p>The height in pixels per tile of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int\n</code></pre> <p>The width in pixels per tile of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>The affine transform mapping pixel coordinates to geographic coordinates.</p> <p>Returns:</p> <ul> <li> <code>Affine</code> (              <code>Affine</code> )          \u2013            <p>The affine transform.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>The width of the overview in pixels.</p>"},{"location":"api/overview/#async_geotiff.Overview.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(xs: list[int], ys: list[int]) -&gt; list[Array]\n</code></pre> <p>Fetch multiple tiles from this overview.</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>list[int]</code>)           \u2013            <p>The x coordinates of the tiles.</p> </li> <li> <code>ys</code>               (<code>list[int]</code>)           \u2013            <p>The y coordinates of the tiles.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""}]}