{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"async-geotiff","text":"<p>Fast, async GeoTIFF and Cloud-Optimized GeoTIFF (COG) reader for Python, wrapping the Rust-based Async-TIFF library.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Read-only support for GeoTIFF and COG formats.</li> <li>High-level, familiar, easy to use API.</li> <li>Performance-focused:<ul> <li>Rust core ensures native performance.</li> <li>CPU-bound tasks like image decoding happen in a thread pool, without blocking the async executor.</li> <li>Buffer protocol integration for zero-copy data sharing between Rust and Python.</li> </ul> </li> <li>Lightweight with no GDAL dependency.</li> <li>Integration with obstore for efficient data access on object stores.</li> <li>Full type hinting for all operations.</li> <li>Broad decompression support: Deflate, LZW, JPEG, JPEG2000, WebP, ZSTD.</li> </ul> <p>Anti-Features (features explicitly not in scope):</p> <ul> <li>No pixel resampling.</li> <li>No warping/reprojection.</li> </ul> <p>Resampling and warping bring significant additional complexity and are out of scope for this library.</p>"},{"location":"#example","title":"Example","text":"<p>First create a \"store\", such as an <code>S3Store</code>, <code>GCSStore</code>, <code>AzureStore</code>, or <code>LocalStore</code> for reading data from AWS S3, Google Cloud, Azure Storage, or local files. Refer to obstore documentation for more information.</p> <pre><code>from obstore.store import S3Store\n\nstore = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True)\npath = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/TCI.tif\"\n</code></pre> <p>Then open a <code>GeoTIFF</code>:</p> <pre><code>from async_geotiff import GeoTIFF\n\ngeotiff = await GeoTIFF.open(path, store=store)\n</code></pre> <p>On the <code>GeoTIFF</code> instance you have metadata about the image, such as its affine transform and Coordinate Reference System:</p> <pre><code>geotiff.transform\n# Affine(10.0, 0.0, 300000.0,\n#        0.0, -10.0, 4100040.0)\n\ngeotiff.crs\n# &lt;Projected CRS: EPSG:32612&gt;\n# Name: WGS 84 / UTM zone 12N\n</code></pre> <p>For a COG, you can access the overviews, or reduced resolution versions, of the image:</p> <pre><code># Overviews are ordered from finest to coarsest resolution\n# In this case, access the second-coarsest resolution version of the image\noverview = geotiff.overviews[-2]\n</code></pre> <p>Then we can read data from the image. This loads a 512-pixel square from the upper-left corner of the selected overview.</p> <pre><code>from async_geotiff import Window\n\nwindow = Window(col_off=0, row_off=0, width=512, height=512)\narray = await overview.read(window=window)\n</code></pre> <p>This <code>Array</code> instance has <code>data</code>, <code>mask</code>, and some other metadata about the fetched array data.</p> <p>Plot, using <code>rasterio.plot.show</code> (requires <code>matplotlib</code>):</p> <pre><code>import rasterio.plot\n\nrasterio.plot.show(array.data)\n</code></pre> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2026-mm-dd","title":"0.1.0 - 2026-MM-DD","text":"<ul> <li>Initial release of async-geotiff.</li> </ul>"},{"location":"api/array/","title":"async_geotiff.Array","text":""},{"location":"api/array/#async_geotiff.Array","title":"async_geotiff.Array  <code>dataclass</code>","text":"<p>               Bases: <code>TransformMixin</code></p> <p>An array representation of data from a GeoTIFF.</p>"},{"location":"api/array/#async_geotiff.Array.count","title":"count  <code>instance-attribute</code>","text":"<pre><code>count: int\n</code></pre> <p>The number of bands in the array.</p>"},{"location":"api/array/#async_geotiff.Array.crs","title":"crs  <code>instance-attribute</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The coordinate reference system of the array.</p>"},{"location":"api/array/#async_geotiff.Array.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: NDArray\n</code></pre> <p>The array data with shape (bands, height, width).</p>"},{"location":"api/array/#async_geotiff.Array.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height: int\n</code></pre> <p>The height of the array in pixels.</p>"},{"location":"api/array/#async_geotiff.Array.mask","title":"mask  <code>instance-attribute</code>","text":"<pre><code>mask: NDArray[bool_] | None\n</code></pre> <p>The mask array with shape (height, width), if any.</p> <p>Values of True indicate valid data; False indicates no data.</p>"},{"location":"api/array/#async_geotiff.Array.nodata","title":"nodata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodata: float | None = None\n</code></pre> <p>The nodata value for the array, if any.</p>"},{"location":"api/array/#async_geotiff.Array.transform","title":"transform  <code>instance-attribute</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>The affine transform mapping pixel coordinates to geographic coordinates.</p>"},{"location":"api/array/#async_geotiff.Array.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width: int\n</code></pre> <p>The width of the array in pixels.</p>"},{"location":"api/array/#async_geotiff.Array.as_masked","title":"as_masked","text":"<pre><code>as_masked() -&gt; MaskedArray\n</code></pre> <p>Return the data as a masked array using the Array mask or nodata value.</p> <p>Warning</p> <p>In a numpy <code>MaskedArray</code>, <code>True</code> indicates invalid (masked) data and <code>False</code> indicates valid data.</p> <p>This is the inverse convention of a GeoTIFF's mask. The boolean array <code>Array.mask</code> uses <code>True</code> for valid data and <code>False</code> for invalid data.</p> <p>Returns:</p> <ul> <li> <code>MaskedArray</code>           \u2013            <p>A masked array with the same shape as <code>data</code>, where invalid data (as indicated by the mask) is masked out.</p> </li> </ul>"},{"location":"api/array/#async_geotiff.Array.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/array/#async_geotiff.Array.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/colormap/","title":"async_geotiff.Colormap","text":""},{"location":"api/colormap/#async_geotiff.colormap","title":"async_geotiff.colormap","text":"<p>High-level Colormap class for GeoTIFF colormaps.</p>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap","title":"Colormap  <code>dataclass</code>","text":"<p>A representation of a GeoTIFF colormap.</p> <p>GeoTIFF colormaps</p>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap.as_array","title":"as_array","text":"<pre><code>as_array(*, dtype: type[uint8 | uint16] = uint8) -&gt; NDArray\n</code></pre> <p>Return the colormap as a NumPy array with shape (N, 3) and dtype uint16.</p> <p>Each row corresponds to a color entry in the colormap, with columns representing the Red, Green, and Blue components respectively.</p> <p>This is the most efficient way to access and apply the colormap data.</p> <pre><code>geotiff = await GeoTIFF.open(...)\narray = await geotiff.fetch_tile(0, 0)\n\ncolormap = geotiff.colormap\ncolormap_array = colormap.as_array()\n\nrgb_data = colormap_array[array.data[0]]\n# A 3D array with shape (height, width, 3)\n</code></pre> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>A NumPy array representation of the colormap.</p> </li> </ul>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, dtype: type[uint8 | uint16] = uint8\n) -&gt; dict[int, tuple[int, int, int]]\n</code></pre> <p>Return the colormap as a dictionary mapping indices to RGB tuples.</p> <p>Returns:</p> <ul> <li> <code>dict[int, tuple[int, int, int]]</code>           \u2013            <p>A dictionary where keys are indices and values are tuples of (Red, Green, Blue) components.</p> </li> </ul>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap.as_rasterio","title":"as_rasterio","text":"<pre><code>as_rasterio() -&gt; dict[int, tuple[int, int, int, int]]\n</code></pre> <p>Return the colormap as a mapping to 8-bit RGBA colors.</p> <p>This returns a colormap in the same format as rasterio's <code>DatasetReader.colormap</code> method.</p> <p>This is the same as <code>Colormap.as_dict</code> with:</p> <ul> <li><code>dtype</code> set to <code>np.uint8</code></li> <li>an added alpha channel set to 255, except for the nodata value, if   defined, which has an alpha of 0.</li> </ul> <p>Returns:</p> <ul> <li> <code>dict[int, tuple[int, int, int, int]]</code>           \u2013            <p>Mapping of color index value (starting at 0) to RGBA color as a 4-element tuple.</p> </li> </ul>"},{"location":"api/geotiff/","title":"async_geotiff.GeoTIFF","text":""},{"location":"api/geotiff/#async_geotiff.GeoTIFF","title":"async_geotiff.GeoTIFF  <code>dataclass</code>","text":"<p>               Bases: <code>ReadMixin</code>, <code>FetchTileMixin</code>, <code>TransformMixin</code></p> <p>A class representing a GeoTIFF image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.block_shapes","title":"block_shapes  <code>property</code>","text":"<pre><code>block_shapes: list[tuple[int, int]]\n</code></pre> <p>An ordered list of block shapes for each bands.</p> <p>Shapes are tuples and have the same ordering as the dataset's shape:</p> <ul> <li>(count of image rows, count of image columns).</li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.bounds","title":"bounds  <code>cached</code> <code>property</code>","text":"<pre><code>bounds: tuple[float, float, float, float]\n</code></pre> <p>Return the bounds of the dataset in the units of its CRS.</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float, float]</code>           \u2013            <p>(lower left x, lower left y, upper right x, upper right y)</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.colorinterp","title":"colorinterp  <code>property</code>","text":"<pre><code>colorinterp: list[str]\n</code></pre> <p>The color interpretation of each band in index order.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.colormap","title":"colormap  <code>property</code>","text":"<pre><code>colormap: Colormap | None\n</code></pre> <p>Return the Colormap stored in the file, if any.</p> <p>Returns:</p> <ul> <li> <code>Colormap | None</code>           \u2013            <p>A Colormap instance if the dataset has a colormap, else None.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.compression","title":"compression  <code>property</code>","text":"<pre><code>compression: Compression\n</code></pre> <p>The compression algorithm used for the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>The number of raster bands in the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The dataset's coordinate reference system.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.dtypes","title":"dtypes  <code>property</code>","text":"<pre><code>dtypes: list[str]\n</code></pre> <p>The data types of each band in index order.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>The height (number of rows) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.interleaving","title":"interleaving  <code>property</code>","text":"<pre><code>interleaving: Interleaving\n</code></pre> <p>The interleaving scheme of the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.is_tiled","title":"is_tiled  <code>property</code>","text":"<pre><code>is_tiled: bool\n</code></pre> <p>Check if the dataset is tiled.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.nodata","title":"nodata  <code>property</code>","text":"<pre><code>nodata: float | None\n</code></pre> <p>The dataset's single nodata value.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.overviews","title":"overviews  <code>property</code>","text":"<pre><code>overviews: list[Overview]\n</code></pre> <p>A list of overview levels for the dataset.</p> <p>Overviews are reduced-resolution versions of the main image used for faster rendering at lower zoom levels.</p> <p>This list of overviews is ordered from finest to coarsest resolution. The first element of the list is the highest-resolution after the base image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.photometric","title":"photometric  <code>property</code>","text":"<pre><code>photometric: PhotometricInterpretation | None\n</code></pre> <p>The photometric interpretation of the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.res","title":"res  <code>property</code>","text":"<pre><code>res: tuple[float, float]\n</code></pre> <p>Return the (width, height) of pixels in the units of its CRS.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int]\n</code></pre> <p>Get the shape (height, width) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int\n</code></pre> <p>The height in pixels per tile of the image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int\n</code></pre> <p>The width in pixels per tile of the image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>Return the dataset's georeferencing transformation matrix.</p> <p>This transform maps pixel row/column coordinates to coordinates in the dataset's CRS.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>The width (number of columns) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.__init__","title":"__init__","text":"<pre><code>__init__(tiff: TIFF) -&gt; None\n</code></pre> <p>Create a GeoTIFF from an existing TIFF instance.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.block_size","title":"block_size","text":"<pre><code>block_size(bidx: int, i: int, j: int) -&gt; int\n</code></pre> <p>Return the size in bytes of a particular block.</p> <p>Parameters:</p> <ul> <li> <code>bidx</code>               (<code>int</code>)           \u2013            <p>Band index, starting with 1.</p> </li> <li> <code>i</code>               (<code>int</code>)           \u2013            <p>Row index of the block, starting with 0.</p> </li> <li> <code>j</code>               (<code>int</code>)           \u2013            <p>Column index of the block, starting with 0.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(xs: list[int], ys: list[int]) -&gt; list[Tile]\n</code></pre> <p>Fetch multiple tiles from this overview.</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>list[int]</code>)           \u2013            <p>The x coordinates of the tiles.</p> </li> <li> <code>ys</code>               (<code>list[int]</code>)           \u2013            <p>The y coordinates of the tiles.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.indexes","title":"indexes","text":"<pre><code>indexes() -&gt; list[int]\n</code></pre> <p>Return the 1-based indexes of each band in the dataset.</p> <p>For a 3-band dataset, this property will be [1, 2, 3].</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.open","title":"open  <code>async</code> <code>classmethod</code>","text":"<pre><code>open(\n    path: str,\n    *,\n    store: ObjectStore | ObspecInput,\n    prefetch: int = 32768,\n    multiplier: float = 2.0\n) -&gt; Self\n</code></pre> <p>Open a new GeoTIFF.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to read from.</p> </li> <li> <code>store</code>               (<code>ObjectStore | ObspecInput</code>)           \u2013            <p>The backend to use for data fetching.</p> </li> <li> <code>prefetch</code>               (<code>int</code>, default:                   <code>32768</code> )           \u2013            <p>The number of initial bytes to read up front.</p> </li> <li> <code>multiplier</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The multiplier to use for readahead size growth. Must be greater than 1.0. For example, for a value of <code>2.0</code>, the first metadata read will be of size <code>prefetch</code>, and then the next read will be of size <code>prefetch * 2</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A TIFF instance.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.read","title":"read  <code>async</code>","text":"<pre><code>read(*, window: Window | None = None) -&gt; Array\n</code></pre> <p>Read pixel data for a window region.</p> <p>This method fetches all tiles that intersect the given window and stitches them together, returning only the pixels within the window.</p> <p>Parameters:</p> <ul> <li> <code>window</code>               (<code>Window | None</code>, default:                   <code>None</code> )           \u2013            <p>A Window object defining the pixel region to read. If None, the entire image is read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Array containing the pixel data for the requested window.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WindowError</code>             \u2013            <p>If the window extends outside the image bounds.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/overview/","title":"async_geotiff.Overview","text":""},{"location":"api/overview/#async_geotiff.Overview","title":"async_geotiff.Overview  <code>dataclass</code>","text":"<p>               Bases: <code>ReadMixin</code>, <code>FetchTileMixin</code>, <code>TransformMixin</code></p> <p>An overview level of a Cloud-Optimized GeoTIFF image.</p>"},{"location":"api/overview/#async_geotiff.Overview.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The coordinate reference system of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>The height of the overview in pixels.</p>"},{"location":"api/overview/#async_geotiff.Overview.nodata","title":"nodata  <code>property</code>","text":"<pre><code>nodata: int | float | None\n</code></pre> <p>The nodata value for the overview, if any.</p>"},{"location":"api/overview/#async_geotiff.Overview.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int\n</code></pre> <p>The height in pixels per tile of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int\n</code></pre> <p>The width in pixels per tile of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>The affine transform mapping pixel coordinates to geographic coordinates.</p> <p>Returns:</p> <ul> <li> <code>Affine</code> (              <code>Affine</code> )          \u2013            <p>The affine transform.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>The width of the overview in pixels.</p>"},{"location":"api/overview/#async_geotiff.Overview.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(xs: list[int], ys: list[int]) -&gt; list[Tile]\n</code></pre> <p>Fetch multiple tiles from this overview.</p> <p>Parameters:</p> <ul> <li> <code>xs</code>               (<code>list[int]</code>)           \u2013            <p>The x coordinates of the tiles.</p> </li> <li> <code>ys</code>               (<code>list[int]</code>)           \u2013            <p>The y coordinates of the tiles.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.read","title":"read  <code>async</code>","text":"<pre><code>read(*, window: Window | None = None) -&gt; Array\n</code></pre> <p>Read pixel data for a window region.</p> <p>This method fetches all tiles that intersect the given window and stitches them together, returning only the pixels within the window.</p> <p>Parameters:</p> <ul> <li> <code>window</code>               (<code>Window | None</code>, default:                   <code>None</code> )           \u2013            <p>A Window object defining the pixel region to read. If None, the entire image is read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Array containing the pixel data for the requested window.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WindowError</code>             \u2013            <p>If the window extends outside the image bounds.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""}]}