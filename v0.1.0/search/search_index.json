{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"async-geotiff","text":"<p>Fast, async GeoTIFF and Cloud-Optimized GeoTIFF (COG) reader for Python, wrapping the Rust-based Async-TIFF library.</p> <p>Documentation website.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Asynchronous, read-only support for GeoTIFF and COG formats.</li> <li>High-level, familiar, easy to use API.<ul> <li>Load from full-resolution or reduced-resolution overviews as 3D NumPy arrays.</li> <li>Simplify handling of nodata values and nodata masks with NumPy.</li> <li>Interpret Coordinate Reference Systems as PyProj CRS objects.</li> <li>Find pixels with geotransforms exposed as Affine matrices.</li> <li>Represent internal COG tile grids as TileMatrixSets via Morecantile integration.</li> </ul> </li> <li>Performance-focused:<ul> <li>Rust core ensures compiled performance.</li> <li>CPU-bound image decoding happens in a thread pool, without blocking the async executor.</li> <li>Buffer protocol integration for zero-copy data sharing between Rust and Python.</li> </ul> </li> <li>Lightweight with no GDAL dependency.</li> <li>Access data from AWS S3, Google Cloud Storage, and Azure Storage via integration with obstore.</li> <li>Full type hinting for all operations.</li> <li>Broad decompression support: Deflate, LZMA, LZW, JPEG, JPEG2000, WebP, ZSTD.</li> <li>Support for any arbitrary backend via obspec protocols.</li> </ul>"},{"location":"#anti-features","title":"Anti-Features","text":"<p>Features explicitly not in scope:</p> <ul> <li>No pixel resampling.</li> <li>No warping/reprojection.</li> <li>Automatic resolution/overview selection</li> </ul> <p>Resampling and warping bring significant additional complexity and are out of scope for this library. Consider using Async-GeoTIFF to load data, then Rasterio's In-Memory Files to resample or reproject data, if needed.</p>"},{"location":"#example","title":"Example","text":"<p>First create a \"store\", such as an <code>S3Store</code>, <code>GCSStore</code>, <code>AzureStore</code>, or <code>LocalStore</code> for reading data from AWS S3, Google Cloud, Azure Storage, or local files. Refer to obstore documentation for more information.</p> <pre><code>from obstore.store import S3Store\n\nstore = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True)\npath = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/TCI.tif\"\n</code></pre> <p>Then open a <code>GeoTIFF</code>:</p> <pre><code>from async_geotiff import GeoTIFF\n\ngeotiff = await GeoTIFF.open(path, store=store)\n</code></pre> <p>On the <code>GeoTIFF</code> instance you have metadata about the image, such as its affine transform and Coordinate Reference System:</p> <pre><code>geotiff.transform\n# Affine(10.0, 0.0, 300000.0,\n#        0.0, -10.0, 4100040.0)\n\ngeotiff.crs\n# &lt;Projected CRS: EPSG:32612&gt;\n# Name: WGS 84 / UTM zone 12N\n</code></pre> <p>For a COG, you can access the overviews, or reduced resolution versions, of the image:</p> <pre><code># Overviews are ordered from finest to coarsest resolution\n# In this case, access the second-coarsest resolution version of the image\noverview = geotiff.overviews[-2]\n</code></pre> <p>Then we can read data from the image. This loads a 512-pixel square from the upper-left corner of the selected overview.</p> <pre><code>from async_geotiff import Window\n\nwindow = Window(col_off=0, row_off=0, width=512, height=512)\narray = await overview.read(window=window)\n</code></pre> <p>This <code>Array</code> instance has <code>data</code>, <code>mask</code>, and some other metadata about the fetched array data.</p> <p>Plot, using <code>rasterio.plot.show</code> (requires <code>matplotlib</code>):</p> <pre><code>import rasterio.plot\n\nrasterio.plot.show(array.data)\n</code></pre> <p></p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2026-02-03","title":"0.1.0 - 2026-02-03","text":"<ul> <li>Initial release of async-geotiff.</li> </ul>"},{"location":"api/array/","title":"Array","text":""},{"location":"api/array/#async_geotiff.Array","title":"async_geotiff.Array  <code>dataclass</code>","text":"<p>               Bases: <code>TransformMixin</code></p> <p>An array representation of data from a GeoTIFF.</p>"},{"location":"api/array/#async_geotiff.Array.count","title":"count  <code>instance-attribute</code>","text":"<pre><code>count: int\n</code></pre> <p>The number of bands in the array.</p>"},{"location":"api/array/#async_geotiff.Array.crs","title":"crs  <code>instance-attribute</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The coordinate reference system of the array.</p>"},{"location":"api/array/#async_geotiff.Array.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: NDArray\n</code></pre> <p>The array data with shape (bands, height, width).</p>"},{"location":"api/array/#async_geotiff.Array.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height: int\n</code></pre> <p>The height of the array in pixels.</p>"},{"location":"api/array/#async_geotiff.Array.mask","title":"mask  <code>instance-attribute</code>","text":"<pre><code>mask: NDArray[bool_] | None\n</code></pre> <p>The mask array with shape (height, width), if any.</p> <p>Values of True indicate valid data; False indicates no data.</p>"},{"location":"api/array/#async_geotiff.Array.nodata","title":"nodata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodata: float | None = None\n</code></pre> <p>The nodata value for the array, if any.</p>"},{"location":"api/array/#async_geotiff.Array.transform","title":"transform  <code>instance-attribute</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>The affine transform mapping pixel coordinates to geographic coordinates.</p>"},{"location":"api/array/#async_geotiff.Array.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width: int\n</code></pre> <p>The width of the array in pixels.</p>"},{"location":"api/array/#async_geotiff.Array.as_masked","title":"as_masked","text":"<pre><code>as_masked() -&gt; MaskedArray\n</code></pre> <p>Return the data as a masked array using the Array mask or nodata value.</p> <p>Warning</p> <p>In a numpy <code>MaskedArray</code>, <code>True</code> indicates invalid (masked) data and <code>False</code> indicates valid data.</p> <p>This is the inverse convention of a GeoTIFF's mask. The boolean array <code>Array.mask</code> uses <code>True</code> for valid data and <code>False</code> for invalid data.</p> <p>Returns:</p> <ul> <li> <code>MaskedArray</code>           \u2013            <p>A masked array with the same shape as <code>data</code>, where invalid data (as indicated by the mask) is masked out.</p> </li> </ul>"},{"location":"api/array/#async_geotiff.Array.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/array/#async_geotiff.Array.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/colormap/","title":"Colormap","text":""},{"location":"api/colormap/#async_geotiff.colormap","title":"async_geotiff.colormap","text":"<p>High-level Colormap class for GeoTIFF colormaps.</p>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap","title":"Colormap  <code>dataclass</code>","text":"<p>A representation of a GeoTIFF colormap.</p> <p>GeoTIFF colormaps</p>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap.as_array","title":"as_array","text":"<pre><code>as_array(*, dtype: type[uint8 | uint16] = uint8) -&gt; NDArray\n</code></pre> <p>Return the colormap as a NumPy array with shape (N, 3) and dtype uint16.</p> <p>Each row corresponds to a color entry in the colormap, with columns representing the Red, Green, and Blue components respectively.</p> <p>This is the most efficient way to access and apply the colormap data.</p> <pre><code>geotiff = await GeoTIFF.open(...)\narray = await geotiff.fetch_tile(0, 0)\n\ncolormap = geotiff.colormap\ncolormap_array = colormap.as_array()\n\nrgb_data = colormap_array[array.data[0]]\n# A 3D array with shape (height, width, 3)\n</code></pre> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>A NumPy array representation of the colormap.</p> </li> </ul>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, dtype: type[uint8 | uint16] = uint8\n) -&gt; dict[int, tuple[int, int, int]]\n</code></pre> <p>Return the colormap as a dictionary mapping indices to RGB tuples.</p> <p>Returns:</p> <ul> <li> <code>dict[int, tuple[int, int, int]]</code>           \u2013            <p>A dictionary where keys are indices and values are tuples of (Red, Green, Blue) components.</p> </li> </ul>"},{"location":"api/colormap/#async_geotiff.colormap.Colormap.as_rasterio","title":"as_rasterio","text":"<pre><code>as_rasterio() -&gt; dict[int, tuple[int, int, int, int]]\n</code></pre> <p>Return the colormap as a mapping to 8-bit RGBA colors.</p> <p>This returns a colormap in the same format as rasterio's <code>DatasetReader.colormap</code> method.</p> <p>This is the same as <code>Colormap.as_dict</code> with:</p> <ul> <li><code>dtype</code> set to <code>np.uint8</code></li> <li>an added alpha channel set to 255, except for the nodata value, if   defined, which has an alpha of 0.</li> </ul> <p>Returns:</p> <ul> <li> <code>dict[int, tuple[int, int, int, int]]</code>           \u2013            <p>Mapping of color index value (starting at 0) to RGBA color as a 4-element tuple.</p> </li> </ul>"},{"location":"api/enums/","title":"Enums","text":""},{"location":"api/enums/#async_geotiff.enums","title":"async_geotiff.enums","text":"<p>Enums used by async_geotiff.</p>"},{"location":"api/enums/#async_geotiff.enums.Compression","title":"Compression","text":"<p>               Bases: <code>Enum</code></p> <p>Available compression algorithms for GeoTIFFs.</p>"},{"location":"api/enums/#async_geotiff.enums.Compression.CCITTFAX3","title":"CCITTFAX3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CCITTFAX3 = 'CCITTFAX3'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.CCITTFAX4","title":"CCITTFAX4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CCITTFAX4 = 'CCITTFAX4'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.CCITTRLE","title":"CCITTRLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CCITTRLE = 'CCITTRLE'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.DEFLATE","title":"DEFLATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFLATE = 'DEFLATE'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.JPEG","title":"JPEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JPEG = 'JPEG'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.JPEG2000","title":"JPEG2000  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JPEG2000 = 'JPEG2000'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.LERC","title":"LERC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LERC = 'LERC'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.LERC_DEFLATE","title":"LERC_DEFLATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LERC_DEFLATE = 'LERC_DEFLATE'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.LERC_ZSTD","title":"LERC_ZSTD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LERC_ZSTD = 'LERC_ZSTD'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.LZMA","title":"LZMA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LZMA = 'LZMA'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.LZW","title":"LZW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LZW = 'LZW'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = 'NONE'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.PACKBITS","title":"PACKBITS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PACKBITS = 'PACKBITS'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.UNCOMPRESSED","title":"UNCOMPRESSED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNCOMPRESSED = 'UNCOMPRESSED'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.WEBP","title":"WEBP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEBP = 'WEBP'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Compression.ZSTD","title":"ZSTD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ZSTD = 'ZSTD'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Interleaving","title":"Interleaving","text":"<p>               Bases: <code>Enum</code></p> <p>GeoTIFF band interleaving options.</p>"},{"location":"api/enums/#async_geotiff.enums.Interleaving.BAND","title":"BAND  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BAND = 'BAND'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.Interleaving.PIXEL","title":"PIXEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PIXEL = 'PIXEL'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation","title":"PhotometricInterpretation","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.BLACK_IS_ZERO","title":"BLACK_IS_ZERO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLACK_IS_ZERO = 'MINISBLACK'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.CIELAB","title":"CIELAB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CIELAB = 'CIELAB'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.CMYK","title":"CMYK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CMYK = 'CMYK'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.RGB","title":"RGB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RGB = 'RGB'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.RGBPALETTE","title":"RGBPALETTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RGBPALETTE = 'PALETTE'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.TRANSPARENCY_MASK","title":"TRANSPARENCY_MASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TRANSPARENCY_MASK = 'MASK'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.WHITE_IS_ZERO","title":"WHITE_IS_ZERO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WHITE_IS_ZERO = 'MINISWHITE'\n</code></pre>"},{"location":"api/enums/#async_geotiff.enums.PhotometricInterpretation.YCBCR","title":"YCBCR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YCBCR = 'YCbCr'\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#async_geotiff.exceptions","title":"async_geotiff.exceptions","text":"<p>Exceptions for async_geotiff package.</p>"},{"location":"api/exceptions/#async_geotiff.exceptions.WindowError","title":"WindowError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for window-related errors.</p>"},{"location":"api/geotiff/","title":"GeoTIFF","text":""},{"location":"api/geotiff/#async_geotiff.GeoTIFF","title":"async_geotiff.GeoTIFF  <code>dataclass</code>","text":"<p>               Bases: <code>ReadMixin</code>, <code>FetchTileMixin</code>, <code>TransformMixin</code></p> <p>A class representing a GeoTIFF image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.bounds","title":"bounds  <code>cached</code> <code>property</code>","text":"<pre><code>bounds: tuple[float, float, float, float]\n</code></pre> <p>Return the bounds of the dataset in the units of its CRS.</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float, float]</code>           \u2013            <p>lower left x, lower left y, upper right x, upper right y</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.colormap","title":"colormap  <code>property</code>","text":"<pre><code>colormap: Colormap | None\n</code></pre> <p>Return the Colormap stored in the file, if any.</p> <p>Returns:</p> <ul> <li> <code>Colormap | None</code>           \u2013            <p>A Colormap instance if the dataset has a colormap, else None.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.compression","title":"compression  <code>property</code>","text":"<pre><code>compression: Compression | None\n</code></pre> <p>The compression algorithm used for the dataset.</p> <p>Returns None if the compression is not recognized.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.count","title":"count  <code>property</code>","text":"<pre><code>count: int\n</code></pre> <p>The number of raster bands in the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The dataset's coordinate reference system.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype | None\n</code></pre> <p>The NumPy data type of the image.</p> <p>Returns None if the data type is unknown/not supported.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>The height (number of rows) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.interleaving","title":"interleaving  <code>property</code>","text":"<pre><code>interleaving: Interleaving\n</code></pre> <p>The interleaving scheme of the dataset.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.is_tiled","title":"is_tiled  <code>property</code>","text":"<pre><code>is_tiled: bool\n</code></pre> <p>Check if the dataset is tiled.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.nodata","title":"nodata  <code>property</code>","text":"<pre><code>nodata: float | None\n</code></pre> <p>The dataset's single nodata value.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.overviews","title":"overviews  <code>property</code>","text":"<pre><code>overviews: list[Overview]\n</code></pre> <p>A list of overview levels for the dataset.</p> <p>Overviews are reduced-resolution versions of the main image used for faster rendering at lower zoom levels.</p> <p>This list of overviews is ordered from finest to coarsest resolution. The first element of the list is the highest-resolution after the base image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.photometric","title":"photometric  <code>property</code>","text":"<pre><code>photometric: PhotometricInterpretation | None\n</code></pre> <p>The photometric interpretation of the dataset.</p> <p>Returns None if the photometric interpretation is not recognized.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.res","title":"res  <code>property</code>","text":"<pre><code>res: tuple[float, float]\n</code></pre> <p>Return the (width, height) of pixels in the units of its CRS.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, int]\n</code></pre> <p>Get the shape (height, width) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int\n</code></pre> <p>The height in pixels per tile of the image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int\n</code></pre> <p>The width in pixels per tile of the image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>Return the dataset's georeferencing transformation matrix.</p> <p>This transform maps pixel row/column coordinates to coordinates in the dataset's CRS.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>The width (number of columns) of the full image.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.__init__","title":"__init__","text":"<pre><code>__init__(tiff: TIFF) -&gt; None\n</code></pre> <p>Create a GeoTIFF from an existing TIFF instance.</p>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(xy: Sequence[tuple[int, int]]) -&gt; list[Tile]\n</code></pre> <p>Fetch multiple tiles from this overview.</p> <p>Parameters:</p> <ul> <li> <code>xy</code>               (<code>Sequence[tuple[int, int]]</code>)           \u2013            <p>The (x, y) coordinates of the tiles.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.open","title":"open  <code>async</code> <code>classmethod</code>","text":"<pre><code>open(\n    path: str,\n    *,\n    store: ObspecInput,\n    prefetch: int = 32768,\n    multiplier: float = 2.0\n) -&gt; Self\n</code></pre> <p>Open a new GeoTIFF.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to read from.</p> </li> <li> <code>store</code>               (<code>ObspecInput</code>)           \u2013            <p>The backend to use for data fetching.</p> </li> <li> <code>prefetch</code>               (<code>int</code>, default:                   <code>32768</code> )           \u2013            <p>The number of initial bytes to read up front.</p> </li> <li> <code>multiplier</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The multiplier to use for readahead size growth. Must be greater than 1.0. For example, for a value of <code>2.0</code>, the first metadata read will be of size <code>prefetch</code>, and then the next read will be of size <code>prefetch * 2</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A GeoTIFF instance.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.read","title":"read  <code>async</code>","text":"<pre><code>read(*, window: Window | None = None) -&gt; Array\n</code></pre> <p>Read pixel data for a window region.</p> <p>This method fetches all tiles that intersect the given window and stitches them together, returning only the pixels within the window.</p> <p>Parameters:</p> <ul> <li> <code>window</code>               (<code>Window | None</code>, default:                   <code>None</code> )           \u2013            <p>A Window object defining the pixel region to read. If None, the entire image is read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Array containing the pixel data for the requested window.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WindowError</code>             \u2013            <p>If the window extends outside the image bounds.</p> </li> </ul>"},{"location":"api/geotiff/#async_geotiff.GeoTIFF.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/overview/","title":"Overview","text":""},{"location":"api/overview/#async_geotiff.Overview","title":"async_geotiff.Overview  <code>dataclass</code>","text":"<p>               Bases: <code>ReadMixin</code>, <code>FetchTileMixin</code>, <code>TransformMixin</code></p> <p>An overview level of a Cloud-Optimized GeoTIFF image.</p>"},{"location":"api/overview/#async_geotiff.Overview.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>The coordinate reference system of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.height","title":"height  <code>property</code>","text":"<pre><code>height: int\n</code></pre> <p>The height of the overview in pixels.</p>"},{"location":"api/overview/#async_geotiff.Overview.nodata","title":"nodata  <code>property</code>","text":"<pre><code>nodata: int | float | None\n</code></pre> <p>The nodata value for the overview, if any.</p>"},{"location":"api/overview/#async_geotiff.Overview.tile_height","title":"tile_height  <code>property</code>","text":"<pre><code>tile_height: int\n</code></pre> <p>The height in pixels per tile of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.tile_width","title":"tile_width  <code>property</code>","text":"<pre><code>tile_width: int\n</code></pre> <p>The width in pixels per tile of the overview.</p>"},{"location":"api/overview/#async_geotiff.Overview.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: Affine\n</code></pre> <p>The affine transform mapping pixel coordinates to geographic coordinates.</p> <p>Returns:</p> <ul> <li> <code>Affine</code> (              <code>Affine</code> )          \u2013            <p>The affine transform.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.width","title":"width  <code>property</code>","text":"<pre><code>width: int\n</code></pre> <p>The width of the overview in pixels.</p>"},{"location":"api/overview/#async_geotiff.Overview.fetch_tiles","title":"fetch_tiles  <code>async</code>","text":"<pre><code>fetch_tiles(xy: Sequence[tuple[int, int]]) -&gt; list[Tile]\n</code></pre> <p>Fetch multiple tiles from this overview.</p> <p>Parameters:</p> <ul> <li> <code>xy</code>               (<code>Sequence[tuple[int, int]]</code>)           \u2013            <p>The (x, y) coordinates of the tiles.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.index","title":"index","text":"<pre><code>index(\n    x: float, y: float, op: Callable[[float], int] = floor\n) -&gt; tuple[int, int]\n</code></pre> <p>Get the (row, col) index of the pixel containing (x, y).</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float</code>)           \u2013            <p>x value in coordinate reference system.</p> </li> <li> <code>y</code>               (<code>float</code>)           \u2013            <p>y value in coordinate reference system.</p> </li> <li> <code>op</code>               (<code>Callable[[float], int]</code>, default:                   <code>floor</code> )           \u2013            <p>Function to convert fractional pixels to whole numbers (floor, ceiling, round). Defaults to math.floor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>(row index, col index)</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.read","title":"read  <code>async</code>","text":"<pre><code>read(*, window: Window | None = None) -&gt; Array\n</code></pre> <p>Read pixel data for a window region.</p> <p>This method fetches all tiles that intersect the given window and stitches them together, returning only the pixels within the window.</p> <p>Parameters:</p> <ul> <li> <code>window</code>               (<code>Window | None</code>, default:                   <code>None</code> )           \u2013            <p>A Window object defining the pixel region to read. If None, the entire image is read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>An Array containing the pixel data for the requested window.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WindowError</code>             \u2013            <p>If the window extends outside the image bounds.</p> </li> </ul>"},{"location":"api/overview/#async_geotiff.Overview.xy","title":"xy","text":"<pre><code>xy(\n    row: int,\n    col: int,\n    offset: Literal[\"center\", \"ul\", \"ur\", \"ll\", \"lr\"] = \"center\",\n) -&gt; tuple[float, float]\n</code></pre> <p>Get the coordinates (x, y) of a pixel at (row, col).</p> <p>The pixel's center is returned by default, but a corner can be returned by setting <code>offset</code> to one of <code>\"ul\"</code>, <code>\"ur\"</code>, <code>\"ll\"</code>, <code>\"lr\"</code>.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>int</code>)           \u2013            <p>Pixel row.</p> </li> <li> <code>col</code>               (<code>int</code>)           \u2013            <p>Pixel column.</p> </li> <li> <code>offset</code>               (<code>Literal['center', 'ul', 'ur', 'll', 'lr']</code>, default:                   <code>'center'</code> )           \u2013            <p>Determines if the returned coordinates are for the center of the pixel or for a corner.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>(x, y) coordinates in the dataset's CRS.</p> </li> </ul>"},{"location":"api/tms/","title":"TileMatrixSet integration","text":""},{"location":"api/tms/#async_geotiff.tms","title":"async_geotiff.tms","text":"<p>Generate a Tile Matrix Set from a GeoTIFF file, using Morecantile.</p>"},{"location":"api/tms/#async_geotiff.tms.generate_tms","title":"generate_tms","text":"<pre><code>generate_tms(geotiff: GeoTIFF, *, id: str = str(uuid4())) -&gt; TileMatrixSet\n</code></pre> <p>Generate a Tile Matrix Set from a GeoTIFF file.</p> <p>Parameters:</p> <ul> <li> <code>geotiff</code>               (<code>GeoTIFF</code>)           \u2013            <p>The GeoTIFF file to generate the TMS from.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>The ID to assign to the Tile Matrix Set.</p> </li> </ul>"},{"location":"api/window/","title":"Window","text":""},{"location":"api/window/#async_geotiff.Window","title":"async_geotiff.Window  <code>dataclass</code>","text":"<p>A rectangular subset of a raster.</p> <p>Windows define pixel regions using column/row offsets and dimensions. This class is similar to rasterio's Window but supports integer offsets and ranges only.</p>"},{"location":"api/window/#async_geotiff.Window.col_off","title":"col_off  <code>instance-attribute</code>","text":"<pre><code>col_off: int\n</code></pre> <p>The column offset (x position of the left edge).</p>"},{"location":"api/window/#async_geotiff.Window.height","title":"height  <code>instance-attribute</code>","text":"<pre><code>height: int\n</code></pre> <p>The height in pixels (number of rows).</p>"},{"location":"api/window/#async_geotiff.Window.row_off","title":"row_off  <code>instance-attribute</code>","text":"<pre><code>row_off: int\n</code></pre> <p>The row offset (y position of the top edge).</p>"},{"location":"api/window/#async_geotiff.Window.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width: int\n</code></pre> <p>The width in pixels (number of columns).</p>"},{"location":"api/window/#async_geotiff.Window.intersection","title":"intersection","text":"<pre><code>intersection(other: Window) -&gt; Window\n</code></pre> <p>Compute the intersection with another window.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Window</code>)           \u2013            <p>Another Window object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Window</code>           \u2013            <p>A new Window representing the overlapping region.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>WindowError</code>             \u2013            <p>If windows do not intersect.</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2026/02/03/introducing-async-geotiff/","title":"Introducing Async-GeoTIFF","text":"<p>We're introducing Async-GeoTIFF, a new high-level library for reading GeoTIFF and Cloud-Optimized GeoTIFF (COG) data. By leveraging asynchronous I/O, we can speed up concurrent GeoTIFF data fetching.</p> <p>According to the 2025 GDAL user survey, almost 90% of respondents use GeoTIFFs and COGs as their primary raster data format. While GDAL and its Python bindings Rasterio are fantastic, rock-solid tools, they don't support asynchronous I/O and are missing some modern Python usability features, like type hinting.</p> <p>We previously found concurrent GeoTIFF metadata parsing at scale to be 25x faster with the underlying Rust-based Async-TIFF library than with Rasterio. We expect Async-GeoTIFF to bring similar performance improvements to concurrent server-side image reading, improving downstream applications such as Titiler.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#high-level-and-easy-to-use","title":"High-Level and Easy-to-Use","text":"<p>We can open up a GeoTIFF using the Obstore integration:</p> <p><pre><code>from async_geotiff import GeoTIFF\nfrom obstore.store import S3Store\n\nstore = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True)\npath = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/TCI.tif\"\ngeotiff = await GeoTIFF.open(path, store=store)\n</code></pre> On the <code>GeoTIFF</code> instance you have metadata about the image, such as its affine transform, exposed as Affine objects, and Coordinate Reference System, exposed as PyProj CRS objects.</p> <pre><code>geotiff.transform\n# Affine(10.0, 0.0, 300000.0,\n#        0.0, -10.0, 4100040.0)\n\ngeotiff.crs\n# &lt;Projected CRS: EPSG:32612&gt;\n# Name: WGS 84 / UTM zone 12N\n\ngeotiff.nodata\n# 0.0\n</code></pre> <p>For a COG, you can access the overviews, or reduced resolution versions, of the image:</p> <pre><code># Overviews are ordered from finest to coarsest resolution\n# In this case, access the second-coarsest resolution version of the image\noverview = geotiff.overviews[-2]\n</code></pre> <p>Then we can read data from the image. This loads a 512-pixel square from the upper-left corner of the selected overview.</p> <pre><code>from async_geotiff import Window\n\nwindow = Window(col_off=0, row_off=0, width=512, height=512)\narray = await overview.read(window=window)\n</code></pre> <p>The <code>read</code> method returns an <code>Array</code> instance, which has fields including <code>data</code>, <code>shape</code>, <code>mask</code>, <code>transform</code>, and <code>crs</code>.</p> <pre><code># The affine transform of the loaded array\narray.transform\n# Affine(79.97086671522214, 0.0, 300000.0,\n#        0.0, -79.97086671522214, 4100040.0)\n</code></pre> <p>The <code>.data</code> attribute is a 3D NumPy array, with rasterio axis ordering <code>(bands, height, width)</code>.</p> <pre><code>array.data\n# array([[[217, 245, 255, ...,   0,   0,   0],\n#         [230, 244, 255, ...,   0,   0,   0],\n#         [251, 254, 255, ...,   0,   0,   0],\n#         ...,\n#         [245, 239, 244, ...,   0,   0,   0],\n#         [243, 236, 239, ...,   0,   0,   0],\n#         [246, 245, 245, ...,   0,   0,   0]],\n\n#        [[135, 170, 229, ...,   0,   0,   0],\n#         [149, 180, 239, ...,   0,   0,   0],\n#         [192, 234, 252, ...,   0,   0,   0],\n#         ...,\n#         [183, 174, 179, ...,   0,   0,   0],\n#         [179, 171, 170, ...,   0,   0,   0],\n#         [191, 182, 180, ...,   0,   0,   0]]],\n#       shape=(3, 512, 512), dtype=uint8)\n</code></pre> <p>Or we can create a NumPy MaskedArray with the <code>as_masked</code> method:</p> <pre><code>array.as_masked()\n# masked_array(\n#   data=[[[217, 245, 255, ..., --, --, --],\n#          [230, 244, 255, ..., --, --, --],\n#          [251, 254, 255, ..., --, --, --],\n#          ...,\n#          [245, 239, 244, ..., --, --, --],\n#          [243, 236, 239, ..., --, --, --],\n#          [246, 245, 245, ..., --, --, --]],\n\n#         [[135, 170, 229, ..., --, --, --],\n#          [149, 180, 239, ..., --, --, --],\n#          [192, 234, 252, ..., --, --, --],\n#          ...,\n#          [183, 174, 179, ..., --, --, --],\n#          [179, 171, 170, ..., --, --, --],\n#          [191, 182, 180, ..., --, --, --]]],\n#   mask=[[[False, False, False, ...,  True,  True,  True],\n#          [False, False, False, ...,  True,  True,  True],\n#          [False, False, False, ...,  True,  True,  True],\n#          ...,\n#          [False, False, False, ...,  True,  True,  True],\n#          [False, False, False, ...,  True,  True,  True],\n#          [False, False, False, ...,  True,  True,  True]]],\n#   fill_value=0,\n#   dtype=uint8)\n</code></pre> <p>This should integrate cleanly into existing tools. For example, we can plot using <code>rasterio.plot.show</code>:</p> <pre><code>import rasterio.plot\n\nrasterio.plot.show(array.data)\n</code></pre> <p></p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#tilematrixset-integration-with-morecantile","title":"TileMatrixSet integration with Morecantile","text":"<p>With the Morecantile integration, we can create a TileMatrixSet representation of the internal COG tiles. This is useful for applications that want to traverse the internal COG tile pyramid structure.</p> <pre><code>from async_geotiff.tms import generate_tms\n\ngenerate_tms(geotiff)\n</code></pre> <pre><code>{\n  \"crs\": {\"uri\": \"http://www.opengis.net/def/crs/EPSG/0/32612\"},\n  \"boundingBox\": {\n    \"lowerLeft\": [300000.0, 3990240.0],\n    \"upperRight\": [409800.0, 4100040.0],\n    \"crs\": {\"uri\": \"http://www.opengis.net/def/crs/EPSG/0/32612\"}\n  },\n  \"tileMatrices\": [\n    {\n      \"id\": \"0\",\n      \"scaleDenominator\": 570804.741110418,\n      \"cellSize\": 159.82532751091702,\n      \"cornerOfOrigin\": \"topLeft\",\n      \"pointOfOrigin\": [300000.0, 4100040.0],\n      \"tileWidth\": 1024,\n      \"tileHeight\": 1024,\n      \"matrixWidth\": 1,\n      \"matrixHeight\": 1\n    },\n    {\n      \"id\": \"1\",\n      \"scaleDenominator\": 285610.23826865054,\n      \"cellSize\": 79.97086671522214,\n      \"cornerOfOrigin\": \"topLeft\",\n      \"pointOfOrigin\": [300000.0, 4100040.0],\n      \"tileWidth\": 1024,\n      \"tileHeight\": 1024,\n      \"matrixWidth\": 2,\n      \"matrixHeight\": 2\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#performance-focused","title":"Performance-focused","text":""},{"location":"blog/2026/02/03/introducing-async-geotiff/#rust-core","title":"Rust core","text":"<p>The underlying Async-TIFF library is written in Rust, a fast, low-level language that compiles to native machine code. This means Async-TIFF and Async-GeoTIFF can be just as fast as any C or C++ library. Rust is memory efficient and its compiler automatically catches many memory bugs.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#multithreaded-image-decoding-by-default","title":"Multithreaded image decoding by default","text":"<p>With asynchronous I/O, it's important to ensure that no blocking tasks happen on the primary executor, because those blocking tasks prevent any other asynchronous tasks from responding.</p> <p>Async-GeoTIFF splits up the I/O-bound network data fetching and CPU-bound image decoding, ensuring any decoding is done in a Rust-based thread pool, leaving the executor responsive.</p> <p>Async-GeoTIFF is thread-safe, though you shouldn't usually need to use it with a Python thread pool, as it's already using a Rust thread pool under the hood.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#efficient-memory-usage","title":"Efficient memory usage","text":"<p>The underlying Async-TIFF library implements the Python Buffer Protocol, ensuring that we can share array data between Rust and NumPy without copies.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#read-geotiffs-cogs-from-any-source","title":"Read GeoTIFFs / COGs from any source","text":""},{"location":"blog/2026/02/03/introducing-async-geotiff/#fast-cloud-storage-access-with-obstore","title":"Fast cloud storage access with Obstore","text":"<p>Obstore is a high-throughput Python interface to Amazon S3, Google Cloud Storage, Azure Storage, &amp; other S3-compliant APIs, powered by a Rust core.</p> <p>Async-GeoTIFF supports Obstore instances out of the box. Just create a store and pass it to <code>GeoTIFF.open</code>.</p> <pre><code>from async_geotiff import GeoTIFF\nfrom obstore.store import S3Store\n\nstore = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True)\npath = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/TCI.tif\"\ngeotiff = await GeoTIFF.open(path, store=store)\n</code></pre>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#generic-backend-support-with-obspec","title":"Generic backend support with obspec","text":"<p>Async-GeoTIFF supports reading from arbitrary Obspec backends. Obspec defines a set of Python protocols for generically accessing data from object storage-like resources.</p> <p>This means you can easily read GeoTIFF data from any source, as long as you define two simple methods:</p> <pre><code>class MyBackend:\n    async def get_range_async(\n        self,\n        path: str,\n        *,\n        start: int,\n        end: int | None = None,\n        length: int | None = None,\n    ) -&gt; Buffer:\n        \"\"\"Return the bytes in the given byte range.\"\"\"\n        ...\n\n    async def get_ranges_async(\n        self,\n        path: str,\n        *,\n        starts: Sequence[int],\n        ends: Sequence[int] | None = None,\n        lengths: Sequence[int] | None = None,\n    ) -&gt; Sequence[Buffer]:\n        \"\"\"Return the bytes in the given byte ranges.\"\"\"\n        ...\n</code></pre> <p>Then just pass an instance of your backend into <code>GeoTIFF.open</code>.</p> <pre><code>from async_geotiff import GeoTIFF\nfrom obstore.store import S3Store\n\nbackend = MyBackend()\ngeotiff = await GeoTIFF.open(\"path/in/backend.tif\", store=backend)\n</code></pre> <p>Read the obspec release post for more information.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#more-tractable-data-caching","title":"More tractable data caching","text":"<p>GDAL provides a block cache per file handle opened. The block cache persists chunks of bytes in memory that have already been read over the network, so that if a later request requires some of those same bytes, a smaller network request to the source is required.</p> <p>However GDAL's block cache is entirely a black box at the Python level. Rasterio is unable to access it, and the end user is unable to see how much data the cache is using. Similarly, the Python user can't change core cache behavior, aside from a few configuration settings.</p> <p>Through Async-GeoTIFF's Obspec integration, we expect to have composable caching layers available to any tool relying on Obspec, including Async-GeoTIFF. We're currently experimenting with ideas in the <code>obspec-utils</code> repository, but the basic idea is</p> <pre><code>from __future__ import annotations\nfrom typing_extensions import Buffer\nfrom typing import Protocol\nfrom obspec import GetRangeAsync, GetRangesAsync\n\nclass FetchClientProtocol(GetRange, GetRangesAsync, Protocol):\n    \"\"\"A new type wrapper for classes that implement both `GetRange` and\n    `GetRangesAsync`.\n    \"\"\"\n    ...\n\nclass SimpleCache(GetRange, GetRangesAsync):\n    \"\"\"A simple cache for range requests that never evicts data.\"\"\"\n\n    def __init__(self, client: GetRange):\n        self.client = client\n        self.cache: dict[tuple[str, int, int | None, int | None], Buffer] = {}\n\n    async def get_range_async(\n        self,\n        path: str,\n        *,\n        start: int,\n        end: int | None = None,\n        length: int | None = None,\n    ) -&gt; Buffer:\n        cache_key = (path, start, end, length)\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n\n        response = await self.client.get_range_async(\n            path,\n            start=start,\n            end=end,\n            length=length,\n        )\n        self.cache[cache_key] = response\n        return response\n\n    async def get_ranges_async(\n        self,\n        path: str,\n        *,\n        starts: Sequence[int],\n        ends: Sequence[int] | None = None,\n        lengths: Sequence[int] | None = None,\n    ) -&gt; Sequence[Buffer]:\n        # This is meant as pseudocode; a real implementation would check each\n        # range against the cache and merge ranges if possible, so as few\n        # requests as possible are made to the actual source\n        results = []\n        for (start, end) in zip(starts, ends):\n            results.append(self.get_range_async(path=path, start=start, end=end))\n        return results\n</code></pre> <p>Now a user could easily choose to add the caching layer as a middleware:</p> <pre><code>from obstore.store import S3Store\nfrom async_geotiff import GeoTIFF\n\nstore = S3Store(\"bucket\")\ncaching_wrapper = SimpleCache(store)\n\ngeotiff = await GeoTIFF.open(\"path/to/image.tif\", store=caching_wrapper)\n</code></pre> <p>The user has full access to the <code>caching_wrapper</code> instance as well, if they want to inspect how much memory it's using or log what requests are made.</p> <p>Read the obspec release post for more information.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#full-type-hinting","title":"Full type hinting","text":"<p>The entire Async-GeoTIFF API is type-hinted as well as possible, leading to effective IDE integration.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#growing-test-suite","title":"Growing test suite","text":"<p>We recently created geotiff-test-data, a repository to hold various sorts of GeoTIFF test files. This repo can then be used as a submodule to provide test fixtures for various repositories like Async-GeoTIFF and deck.gl-raster without growing the disk size of the primary Git repository.</p> <p>The majority of these test files are written using Rasterio</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#future-work","title":"Future work","text":""},{"location":"blog/2026/02/03/introducing-async-geotiff/#rio-tiler-integration","title":"<code>rio-tiler</code> integration","text":"<p><code>rio-tiler</code> is a foundational library for accessing raster data for tiled web maps. And Titiler, a Development Seed project for dynamic server-side raster tile generation, is built largely on the backs of <code>rio-tiler</code>. The first step of integrating Async-GeoTIFF into the Titiler ecosystem will be adding support to <code>rio-tiler</code>.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#better-api-for-handling-photometric-interpretations","title":"Better API for handling photometric interpretations","text":"<p>Currently Async-GeoTIFF doesn't decode data out of RGB color spaces like YCbCr, which doesn't match Rasterio's handling. We may add an API like <code>Array.to_rgb</code> to offer explicit conversion to an RGB color space.</p>"},{"location":"blog/2026/02/03/introducing-async-geotiff/#more-compression-support","title":"More compression support","text":"<p>We should support additional compressions like LERC and JPEG XL.</p>"},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/category/release/","title":"Release","text":""}]}